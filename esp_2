#include <libpynq.h>
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>

//create a struct called coordinates which can maintain the location of the robot
struct coordinates {
    int x; 
    int y;
    char* objectAtLocation;
};

struct squareType { // Prototype, might not end up being used
    //blockType: 0 is not a block, 1 is a smol block, 2 is a big block
    int blockType;
    //block color: 1 is black, 2 is blue, 3 is green, 4 is red, 5 is white. Will not be checked if not a block, could be 0
    int blockColor;
    //parity value
    int cliffPresent;
    //parity value for hole
    int holePresent;
    //parity value for boundary 
    int boundaryPresent;
    //Direction of the boundary: 0 is north/top, 1 is south/bottom, 2 is west/left, 3 is east/right. Will not be checked if no boundary
    int boundarySide;
};
//
//int getID(squareType square){
//    int ID = 0;
//    switch (square.blockType) {
//        case 0:
//            return 0;
//        case 1:
//            return 1;
//        case 2:
//            return 2;
//        other:
//            return 100; // error
//    }
//}

// char returnSingleCharFromSquareProperty(char* c){
//     if(c == "Boundary"){
//         return char "b";
//     }
// }

void send_message(char* message){
    if(sizeof(message) > 256){
        printf("Message contains too much chars\n");
    }
    else if(sizeof(message) <= 0){
        printf("Message contains no information\n");
    }
    else{
        uint32_t length = strlen(message) - 1;
        uint8_t* len_bytes = (uint8_t*)&length;

        fflush(NULL);

        //send length
        for(uint32_t i = 0; i < 4; i++){
            uart_send(UART0, len_bytes[i]);
        }
        //send message
        for(uint32_t i = 0; i < length; i++){
            uart_send(UART0, message[i]);
        }
        printf("Message is sent\n");
    }
}

char* glue(int ID, int x, int y) {
    char x_c[12] = "";
    char y_c[12] = "";
    char ID_C[12] = ""; // Increase the size to handle more than single-digit IDs

    sprintf(x_c, "%d", x);
    sprintf(y_c, "%d", y);
    sprintf(ID_C, "%d", ID);

    // Allocate enough memory for the resulting string
    char *result = (char *)malloc(strlen(ID_C) + strlen(x_c) + strlen(y_c) + 3); // +3 for 2 commas and null terminator
    if (result == NULL) {
        // Handle memory allocation failure
        return NULL;
    }

    // Construct the resulting string
    strcpy(result, ID_C);
    strcat(result, ",");
    strcat(result, x_c);
    strcat(result, ",");
    strcat(result, y_c);

    return result;
}

void send_location_object(struct coordinates coordinates, struct squareType squareType){
    int messageID = 1;

    char* output = glue(messageID, coordinates.x, coordinates.y);
  
    printf("Message: %s\n", output);

    send_message(output);
}

void send_location_robot(struct coordinates coordinates){
    int messageID = 0;

    char* output = glue(messageID, coordinates.x, coordinates.y);
  
    printf("Message: %s\n", output);

    send_message(output);
}

int main()
{
    printf("Boom\n");
    switchbox_init();
    switchbox_set_pin(IO_AR0, SWB_UART0_RX);
    switchbox_set_pin(IO_AR1, SWB_UART0_TX);

    // initialize UART 0
    uart_init(UART0);
    // flush FIFOs of UART 0
    uart_reset_fifos(UART0);

    // char buf[256];
    fcntl(0, F_SETFL, fcntl(0, F_GETFL) | O_NONBLOCK);



    struct coordinates currentCoordinate;
    //create the initial coordinate which can be assumed as empty
    currentCoordinate.x = 123;
    currentCoordinate.y = 684;
    currentCoordinate.objectAtLocation = "Empty";

    printf("Boom\n");

    send_location_robot(currentCoordinate);

    printf("Done\n");

    // algorythm
    
    // send location of robot

    // send data of objects, inputs an array
        // convert array to a char

    // unity // 
        // receive char
            // convert to array
                // visualize

    

    

    // void send_object_information(struct coordinates coordinates){
    //     char x = (char) coordinates.x;
    //     char y = (char) coordinates.y;
    //     // coordinates are stored with 6 digits
    //     while(strlen(x) < 6){
    //         x = "0" + x;
    //     }
    //     while(strlen(y) < 6){
    //         y = "0" + y;
    //     }
    //     char c = "o" + x + y + returnSingleCharFromSquareProperty(coordinates.objectAtLocation);

        
    //     send_message(c);
    // }

    







    // while (1)
    // { 
    //     int numRead = read(0, buf, 256);
    //     if(numRead > 0)    
    //     {
    //         uint32_t length = numRead - 1;
    //         uint8_t* len_bytes = (uint8_t*)&length;
    //             printf("<< Outgoing Message: Size = %d\n", length);
    //         fflush(NULL);    
    //         for(uint32_t i = 0; i < 4; i++)
    //         {
    //             uart_send(UART0, len_bytes[i]);
    //         }
    //         for(uint32_t i = 0; i < length; i++)
    //         {
    //             uart_send(UART0, buf[i]);
    //         }    
    //     } 
    //     if(uart_has_data(UART0))
    //         {
    //         uint8_t read_len[4];
    //         for(uint32_t i = 0; i < 4; i++)
    //         {
    //             read_len[i] = uart_recv(UART0);
    //         }
    //         uint32_t length = *((uint32_t*)read_len);    
    //         printf(">> Incoming Message: Length = %d\n", length);
    //         fflush(NULL);
    //         uint32_t i = 0;    
    //         char* buffer = (char*) malloc(sizeof(char) * length);
    //         while(i < length)
    //         {
    //             buffer[i] = (char)uart_recv(UART0);
    //             i++;
    //         }
    //         printf("  >%s\n", buffer);
    //         fflush(NULL);
    //         free(buffer);
    //     }
    // }
    fflush(NULL);
    uart_reset_fifos(UART0);
    uart_destroy(UART0);
    // clean up after use
    pynq_destroy();
    return EXIT_SUCCESS;
}
