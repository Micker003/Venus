#include <libpynq.h>
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>

//create a struct called coordinates which can maintain the location of the robot
struct coordinates {
    int x; 
    int y;
    char* objectAtLocation;
};

void send_message(char* message){
    if(strlen(message) > 256){
        printf("Message contains too much chars\n");
    }
    else if(strlen(message) == 0){
        printf("Message contains no information\n");
    }
    else{
        uint32_t length = strlen(message);
        uint8_t* len_bytes = (uint8_t*)&length;

        fflush(NULL);

        // Send length
        for(uint32_t i = 0; i < 4; i++){
            uart_send(UART0, len_bytes[i]);
        }
        // Send message
        for(uint32_t i = 0; i < length; i++){
            uart_send(UART0, message[i]);
        }
        printf("Message is sent\n");
    }
}

void decodeMessage(const char *message, int *ID, struct coordinates* coordinates){
    // Use sscanf to parse the integers from the message string
    coordinates->objectAtLocation = "Empty";
    sscanf(message, "%d,%d,%d", ID, &(coordinates->x), &(coordinates->y));
}

char* receive_message(int *ID, struct coordinates* coordinates){
    uint8_t read_len[4];
    for(uint32_t i = 0; i < 4; i++)
    {
        read_len[i] = uart_recv(UART0);
    }
    uint32_t length = *((uint32_t*)read_len);    
    printf(">> Incoming Message: Length = %d\n", length);
    fflush(NULL);
    uint32_t i = 0;    
    char* buffer = (char*) malloc(sizeof(char) * (length + 1)); // +1 for null terminator
    while(i < length)
    {
        buffer[i] = (char)uart_recv(UART0);
        i++;
    }
    buffer[length] = '\0'; // Null terminate the string
    printf("  >%s\n", buffer);
    fflush(NULL);
    decodeMessage(buffer, ID, coordinates);
    return buffer;
}

char* glue(int ID, struct coordinates coordinates) {
    char ID_C[12] = ""; // Increase the size to handle more than single-digit IDs
    char x_c[12] = "";
    char y_c[12] = "";
    
    sprintf(ID_C, "%d", ID);
    sprintf(x_c, "%d", coordinates.x);
    sprintf(y_c, "%d", coordinates.y);
    
    // Calculate the total length of the resulting string
    size_t total_length = strlen(ID_C) + strlen(x_c) + strlen(y_c) + 2 + 1; // 2 commas and 1 null terminator

    // Allocate enough memory for the resulting string
    char *result = (char *)malloc(total_length);
    if (result == NULL) {
        // Handle memory allocation failure
        return NULL;
    }

    // Construct the resulting string
    strcpy(result, ID_C);
    strcat(result, ",");
    strcat(result, x_c);
    strcat(result, ",");
    strcat(result, y_c);
    
    return result;
}

void send_information(int ID, struct coordinates coordinates){
    char* output = glue(ID, coordinates);
    printf("Message: %s\n", output);
    send_message(output);
    free(output); // Free allocated memory
}

void receive_information(int *ID, struct coordinates* coordinates) {
    char *message = receive_message(ID, coordinates);
    if (message != NULL) {
        printf("Received message: %d, %d, %d\n", *ID, coordinates->x, coordinates->y);
        free(message); // Free allocated memory
    }
}

int main() {
    printf("Boom\n");
    switchbox_init();
    switchbox_set_pin(IO_AR0, SWB_UART0_RX);
    switchbox_set_pin(IO_AR1, SWB_UART0_TX);

    // Initialize UART 0
    uart_init(UART0);
    // Flush FIFOs of UART 0
    uart_reset_fifos(UART0);

    fcntl(0, F_SETFL, fcntl(0, F_GETFL) | O_NONBLOCK);

    struct coordinates currentCoordinate;
    struct coordinates receivedCoordinates;

    // Create the initial coordinate which can be assumed as empty
    currentCoordinate.x = 123;
    currentCoordinate.y = 684;
    currentCoordinate.objectAtLocation = "Empty";
    int ID = 0;

    send_information(ID, currentCoordinate);
    if(uart_has_data(UART0)){
        receive_information(&ID, &receivedCoordinates);
        printf("Received message: %d, %d, %d\n", ID, receivedCoordinates.x, receivedCoordinates.y);
    }

    printf("Done\n");

    fflush(NULL);
    uart_reset_fifos(UART0);
    uart_destroy(UART0);
    // Clean up after use
    pynq_destroy();
    return EXIT_SUCCESS;
}
