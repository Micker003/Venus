#include <libpynq.h>
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>

//create a struct called coordinates which can maintain the location of the robot
struct coordinates {
    int x; 
    int y;
    char* objectAtLocation;
};

struct squareType { // Prototype, might not end up being used
    //blockType: 0 is not a block, 1 is a smol block, 2 is a big block
    int blockType;
    //block color: 1 is black, 2 is blue, 3 is green, 4 is red, 5 is white. Will not be checked if not a block, could be 0
    int blockColor;
    //parity value
    int cliffPresent;
    //parity value for hole
    int holePresent;
    //parity value for boundary 
    int boundaryPresent;
    //Direction of the boundary: 0 is north/top, 1 is south/bottom, 2 is west/left, 3 is east/right. Will not be checked if no boundary
    int boundarySide;
};
//
//int getID(squareType square){
//    int ID = 0;
//    switch (square.blockType) {
//        case 0:
//            return 0;
//        case 1:
//            return 1;
//        case 2:
//            return 2;
//        other:
//            return 100; // error
//    }
//}

// char returnSingleCharFromSquareProperty(char* c){
//     if(c == "Boundary"){
//         return char "b";
//     }
// }

void send_message(char* message){
    if(sizeof(message) > 256){
        printf("Message contains too much chars\n");
    }
    else if(sizeof(message) <= 0){
        printf("Message contains no information\n");
    }
    else{
        uint32_t length = strlen(message) - 1;
        uint8_t* len_bytes = (uint8_t*)&length;

        fflush(NULL);

        //send length
        for(uint32_t i = 0; i < 4; i++){
            uart_send(UART0, len_bytes[i]);
        }
        //send message
        for(uint32_t i = 0; i < length; i++){
            uart_send(UART0, message[i]);
        }
        printf("Message is sent\n");
    }
}

void send_location_robot(struct coordinates coordinates){
    // Convert integer to string
    int messageID = 0;
    char x[12] = "";
    char y[12]= "";
    char ID[2] = "";
    sprintf(x, "%d", coordinates.x);
    sprintf(y, "%d", coordinates.y);
    sprintf(ID, "%d", messageID);

    char output[256] = "";
    strcat(output, ID);
    strcat(output, ",");
    strcat(output, x);
    strcat(output, ",");
    strcat(output, y);
    
    // coordinates are stored with 7 digits
    // while(sizeof(x) < 6){
    //     x = '0' + x;
    // }
    // while(sizeof(y) < 6){
    //     y = '0' + y;
    // }
    //char* c = x + y;
  
    printf("Message: %s\n", output);

    send_message(output);
}

int main()
{
    printf("Boom\n");
    switchbox_init();
    switchbox_set_pin(IO_AR0, SWB_UART0_RX);
    switchbox_set_pin(IO_AR1, SWB_UART0_TX);

    // initialize UART 0
    uart_init(UART0);
    // flush FIFOs of UART 0
    uart_reset_fifos(UART0);

    // char buf[256];
    fcntl(0, F_SETFL, fcntl(0, F_GETFL) | O_NONBLOCK);



    struct coordinates currentCoordinate;
    //create the initial coordinate which can be assumed as empty
    currentCoordinate.x = 123;
    currentCoordinate.y = 684;
    currentCoordinate.objectAtLocation = "Empty";

    printf("Boom\n");

    send_location_robot(currentCoordinate);

    // algorythm
    
    // send location of robot

    // send data of objects, inputs an array
        // convert array to a char

    // unity // 
        // receive char
            // convert to array
                // visualize

    

    

    // void send_object_information(struct coordinates coordinates){
    //     char x = (char) coordinates.x;
    //     char y = (char) coordinates.y;
    //     // coordinates are stored with 6 digits
    //     while(strlen(x) < 6){
    //         x = "0" + x;
    //     }
    //     while(strlen(y) < 6){
    //         y = "0" + y;
    //     }
    //     char c = "o" + x + y + returnSingleCharFromSquareProperty(coordinates.objectAtLocation);

        
    //     send_message(c);
    // }

    







    // while (1)
    // { 
    //     int numRead = read(0, buf, 256);
    //     if(numRead > 0)    
    //     {
    //         uint32_t length = numRead - 1;
    //         uint8_t* len_bytes = (uint8_t*)&length;
    //             printf("<< Outgoing Message: Size = %d\n", length);
    //         fflush(NULL);    
    //         for(uint32_t i = 0; i < 4; i++)
    //         {
    //             uart_send(UART0, len_bytes[i]);
    //         }
    //         for(uint32_t i = 0; i < length; i++)
    //         {
    //             uart_send(UART0, buf[i]);
    //         }    
    //     } 
    //     if(uart_has_data(UART0))
    //         {
    //         uint8_t read_len[4];
    //         for(uint32_t i = 0; i < 4; i++)
    //         {
    //             read_len[i] = uart_recv(UART0);
    //         }
    //         uint32_t length = *((uint32_t*)read_len);    
    //         printf(">> Incoming Message: Length = %d\n", length);
    //         fflush(NULL);
    //         uint32_t i = 0;    
    //         char* buffer = (char*) malloc(sizeof(char) * length);
    //         while(i < length)
    //         {
    //             buffer[i] = (char)uart_recv(UART0);
    //             i++;
    //         }
    //         printf("  >%s\n", buffer);
    //         fflush(NULL);
    //         free(buffer);
    //     }
    // }
    fflush(NULL);
    uart_reset_fifos(UART0);
    uart_destroy(UART0);
    // clean up after use
    pynq_destroy();
    return EXIT_SUCCESS;
}
