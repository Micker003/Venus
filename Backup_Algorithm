#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <libpynq.h>
#include "embeddedInitialImp.h"
#include <stepper.h>


typedef struct point{
    int x;
    int y;
    struct point *next;

}point;

typedef struct{
    int height;
    char color[LENGTH] ;
    int x;
    int y;

}rock;

typedef struct{;
    int x;
    int y;
}Hill;


int  checkforobstacle(int x, int y,int *direction){
    // check if there's any obstacle ahead
    // using the distance sensors, check for the height of the obstacle
    // if less than 30 cm find the color of the bot using the color sensor

    int height;
    char color;
    int  forward_distance;
    int downward_distance;
    int threshold = 268;
    struct IRSensors IRData = measureIRData();

    forward_distance = forwardDistanceData();
    downward_distance = downwardDistanceData();

    if((forward_distance<70)||IRData.sensor1Val<threshold||downward_distance<10000){
        //check for the crater
        
        if (IRData.sensor1Val<268||IRData.sensor2Val<268||IRData.sensor3Val<268||IRData.sensor4Val<268){
            // send data
            // send the coordinates
            printf("Robot turned 90 degrees right\n");
            stepper_enable();
            stepper_set_speed(65535,65535);
            stepper_steps(-500,450);
            stepper_disable();
            sleep_msec(1000);
            *direction = *direction + 1;
            return 0;
        }

        // height from the sensor to the ground =  10 cm
        // therefore the height of the block 10-downward_distance
        height = 10-(downward_distance/10);

        if (height != 0){
            color = colorSensor();
            stepper_enable();
            printf("Rock sample detected\n");
            printf("color is %c\n",color);
            printf("Robot turned 90 degrees right\n");
            stepper_set_speed(65535,65535);
            stepper_steps(-500,450);
            stepper_disable();
            sleep_msec(1000);
            // send data to visualisation
            // send coordinates
            *direction = *direction + 1;
            return 0;
        } 
    else{
        printf("HILL detected");
        // send data to visualisation
        // send coordinates
        printf("Robot turned 90 degrees right\n");
        stepper_enable();
        stepper_set_speed(65535,65535);
        stepper_disable();
        sleep_msec(1000);
        *direction = *direction + 1;
        return 0;
        }
    }
    printf("Empty Space\n");
    return 1;
}

void move(int *xpoint, int *ypoint, int direction){

    stepper_enable();
    stepper_set_speed(20000,20000);
    stepper_steps(500,500);
    stepper_disable();
    sleep_msec(1000);
    if (direction == 0){
        *ypoint = *ypoint + 1;
        return;
    }
    else if (direction == 1){
        *xpoint = *xpoint + 1;
    }
    else if (direction == 2){
        *ypoint = *ypoint - 1;
    }
    else if (direction == 3){
        *xpoint = *xpoint - 1;
    }
    else{
        if(direction % 4 == 0){
            *ypoint = *ypoint + 1;
             return;
        }
        if( direction % 4 == 1){
            *xpoint = *xpoint + 1;
        }
        if (direction % 4 == 2){
            *ypoint = *ypoint - 1;
        }
        if(direction % 4 == 3){
            *xpoint = *xpoint - 1;
        }
    }

}


point *addtolist(int x,int y,point *list){
    // insert tail logic
    
    point *current = list;
    if(list == NULL){
        list = malloc(sizeof(point));
        list->x = x;
        list->y = y;
        list->next = NULL;
        return list;
    }
    else{
        while(current->next != NULL){
            current = current->next;
        }
        point *newnode = malloc(sizeof(point));
        newnode->x = x;
        newnode->y= y;
        newnode->next = NULL;
        current->next =newnode;
        
        return list;
    }
    
}

void printmap(){
      for(int i=0;i<19;i++){
            if(i == 9){
                for(int k = 0;k<45;k++){
                    printf("-");
                }
                printf("\n");
            }
            else{
                for(int j = 0; j<20;j++){
                printf(" ");
                }
                printf("|\n");
            }
        }
}

int checklist(int x,int y,point *list){
    
    point *current = list;
    int counter = 0;
    
    while(current != NULL){
        if ((current->x == x)&&(current->y==y)){
            counter = counter + 1;
        }
        current = current->next;
    }
    
    if(counter>2){
        return 1;
    }
    return 0;
}

int double_check_list(point *list){
// checks if all the points in the list repeats twice 


    int count = 0;
    if (list == NULL){
        return 0;
    }

    int hash[100][100] = {0};
    point *temp = list;
    else{

        while(temp != NULL){
            hash[temp->x][temp->y]++;
            temp = temp->next;
        }
        temp = list;

        while(temp != NULL){
            if(hash[temp->x][temp->y]<2){
                return 0;
            }
            temp = temp->next;
        }

        return 1;
    }
    	
}

void printlist(point *list){
    point *current = list;

    printf("Points in the list");
    while(current != NULL){
        printf("(%d,%d)\n",current->x,current->y);
        current = current->next;
    }
}

 


int main (void){

    int checker = 0;
    int check_coordinates = 0;
    point *list = NULL;
    int current_xpoint = 0;
    int current_ypoint = 0;
    stepper_init();
    pynq_init();
    embeddedInit();
    
    list = addtolist(current_xpoint,current_ypoint,list);
    int valid = double_check_list(list);
    
    int direction = 0; 
    printf(" start position is %d %d\n",current_xpoint,current_ypoint);

    while(valid == 0){
        checker = checkforobstacle(current_xpoint,current_ypoint, &direction);
        if(checker == 1){
            if(list != NULL){
            check_coordinates = checklist(current_xpoint,current_ypoint,list);
             }
             if(check_coordinates == 1){
                //Robot turns 90 degrees to the right
                stepper_enable();
                stepper_set_speed(65535,65535);
                stepper_steps(-500,450);
                direction = direction + 1;
                stepper_disable();
                sleep_msec(1000);
             }
            move(&current_xpoint,&current_ypoint,direction);
            list = addtolist(current_xpoint,current_ypoint,list);
             
        }
        printf("Current position %d %d\n",current_xpoint,current_ypoint);

        printlist(list);
        
  
}

return 0;
stepper_destroy();
pynq_destroy();

}
